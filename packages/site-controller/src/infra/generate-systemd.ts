#!/usr/bin/env bun

/**
 * Generate systemd service files from server-config.json
 *
 * Single source of truth: SERVER_CONFIG_PATH env var â†’ server-config.json
 *
 * Usage: bun run gen:systemd
 */

import { execSync } from "node:child_process"
import { constants } from "node:fs"
import { access, mkdir, readFile, writeFile } from "node:fs/promises"
import { parseServerConfig, requireEnv, type ServerConfig } from "@webalive/shared"

interface ServiceConfig {
  name: string
  description: string
  workingDir: string
  execStart: string
  port: number
  env: "development" | "production"
  envFiles: string[]
  memory: { max: string; high: string }
  cpu: string
  syslogId: string
}

// =============================================================================
// Constants
// =============================================================================

const CONFIG_PATH = requireEnv("SERVER_CONFIG_PATH")

const COLORS = {
  red: "\x1b[31m",
  green: "\x1b[32m",
  yellow: "\x1b[33m",
  reset: "\x1b[0m",
  dim: "\x1b[2m",
}

// =============================================================================
// Dependency Checks
// =============================================================================

async function checkDependencies(): Promise<string> {
  const errors: string[] = []

  // Check bun
  const bunPath = findExecutable("bun", [
    "/root/.bun/bin/bun",
    "/usr/local/bin/bun",
    "/usr/bin/bun",
    `${process.env.HOME}/.bun/bin/bun`,
  ])

  if (!bunPath) {
    errors.push(`${COLORS.red}âœ— bun not found${COLORS.reset}
    Install: curl -fsSL https://bun.sh/install | bash`)
  }

  // Check server config
  try {
    await access(CONFIG_PATH, constants.R_OK)
  } catch {
    errors.push(`${COLORS.red}âœ— ${CONFIG_PATH} not found${COLORS.reset}
    Fix: cp ops/server-config.example.json ${CONFIG_PATH}
    Then edit with your server's values`)
  }

  if (errors.length > 0) {
    console.error("\nðŸš¨ Missing dependencies:\n")
    errors.forEach(e => {
      console.error(`${e}\n`)
    })
    process.exit(1)
  }

  return bunPath!
}

function findExecutable(name: string, candidates: string[]): string | null {
  // Try which first
  try {
    const path = execSync(`which ${name} 2>/dev/null`, { encoding: "utf8" }).trim()
    if (path) return path
  } catch {
    /* continue */
  }

  // Check candidates
  for (const path of candidates) {
    try {
      execSync(`test -x "${path}"`)
      return path
    } catch {
      /* continue */
    }
  }

  return null
}

// =============================================================================
// Go Service Config (for Go binaries like preview-proxy)
// =============================================================================

interface GoServiceConfig {
  name: string
  description: string
  workingDir: string
  execStart: string
  envFiles: string[]
  envVars: Record<string, string>
  memory: { max: string; high: string }
  cpu: string
  tasksMax: number
  syslogId: string
}

// =============================================================================
// Service Templates
// =============================================================================

function generateService(cfg: ServiceConfig): string {
  const envFileLines = cfg.envFiles.map(f => `EnvironmentFile=-${f}`).join("\n")

  return `# Generated by: bun run gen:systemd
# Source: ${CONFIG_PATH}

[Unit]
Description=${cfg.description}
After=network.target
StartLimitIntervalSec=300
StartLimitBurst=3

[Service]
Type=simple
WorkingDirectory=${cfg.workingDir}
ExecStart=${cfg.execStart}

${envFileLines}

Environment="NODE_ENV=${cfg.env}"
Environment="PORT=${cfg.port}"
${cfg.env === "production" ? `Environment="ALIVE_API_PORT=${cfg.port}"` : ""}

MemoryMax=${cfg.memory.max}
MemoryHigh=${cfg.memory.high}
CPUQuota=${cfg.cpu}
TasksMax=${cfg.env === "development" ? 1024 : 512}
LimitNOFILE=${cfg.env === "development" ? 8192 : 4096}

Restart=on-failure
RestartSec=${cfg.env === "development" ? "5s" : "10s"}
${cfg.env === "production" ? "TimeoutStopSec=10s" : ""}

StandardOutput=journal
StandardError=journal
SyslogIdentifier=${cfg.syslogId}

[Install]
WantedBy=multi-user.target
`
}

function generateGoService(cfg: GoServiceConfig): string {
  const envFileLines = cfg.envFiles.map(f => `EnvironmentFile=-${f}`).join("\n")
  const envVarLines = Object.entries(cfg.envVars)
    .map(([k, v]) => `Environment="${k}=${v}"`)
    .join("\n")

  return `# Generated by: bun run gen:systemd
# Source: ${CONFIG_PATH}

[Unit]
Description=${cfg.description}
After=network.target
StartLimitIntervalSec=300
StartLimitBurst=3

[Service]
Type=simple
WorkingDirectory=${cfg.workingDir}
ExecStart=${cfg.execStart}

${envFileLines}

${envVarLines}

MemoryMax=${cfg.memory.max}
MemoryHigh=${cfg.memory.high}
CPUQuota=${cfg.cpu}
TasksMax=${cfg.tasksMax}
LimitNOFILE=4096

Restart=on-failure
RestartSec=5s
TimeoutStopSec=10s
TimeoutStartSec=10s

StandardOutput=journal
StandardError=journal
SyslogIdentifier=${cfg.syslogId}

[Install]
WantedBy=multi-user.target
`
}

// =============================================================================
// Main
// =============================================================================

async function main() {
  console.log("ðŸ”§ Generating systemd services...\n")

  // Check dependencies first
  const bunPath = await checkDependencies()

  // Load and validate config (Zod schema validates all required fields)
  const raw = await readFile(CONFIG_PATH, "utf8")
  const config: ServerConfig = parseServerConfig(raw)

  const { aliveRoot } = config.paths
  const { dir: generatedDir } = config.generated
  await mkdir(generatedDir, { recursive: true })

  console.log(`  aliveRoot: ${aliveRoot}`)
  console.log(`  bunPath:    ${bunPath}`)
  console.log(`  output:     ${generatedDir}\n`)

  // Define all services (DRY - data-driven)
  const services: ServiceConfig[] = [
    {
      name: "alive-dev",
      description: "Alive Development",
      workingDir: `${aliveRoot}/apps/web`,
      execStart: `${bunPath} run dev`,
      port: 8997,
      env: "development",
      envFiles: [`${aliveRoot}/.env.local`, `${aliveRoot}/apps/web/.env.local`],
      memory: { max: "4G", high: "3G" },
      cpu: "400%",
      syslogId: "alive-dev",
    },
    {
      name: "alive-staging",
      description: "Alive Staging",
      workingDir: `${aliveRoot}/.builds/staging/current/standalone`,
      execStart: `${bunPath} ${aliveRoot}/.builds/staging/current/standalone/apps/web/server.js`,
      port: 8998,
      env: "production",
      envFiles: [`${aliveRoot}/.env.local`, `${aliveRoot}/apps/web/.env.staging`],
      memory: { max: "2G", high: "1.5G" },
      cpu: "200%",
      syslogId: "alive-staging",
    },
    {
      name: "alive-production",
      description: "Alive Production",
      workingDir: `${aliveRoot}/.builds/production/current/standalone`,
      execStart: `${bunPath} ${aliveRoot}/.builds/production/current/standalone/apps/web/server.js`,
      port: 9000,
      env: "production",
      envFiles: [`${aliveRoot}/.env.local`, `${aliveRoot}/apps/web/.env.production`],
      memory: { max: "2G", high: "1.5G" },
      cpu: "200%",
      syslogId: "alive-production",
    },
    {
      name: "alive-broker",
      description: "Alive Broker",
      workingDir: `${aliveRoot}/apps/broker`,
      execStart: `${bunPath} run start`,
      port: 3001,
      env: "production",
      envFiles: [`${aliveRoot}/.env.local`, `${aliveRoot}/apps/broker/.env.local`],
      memory: { max: "512M", high: "384M" },
      cpu: "100%",
      syslogId: "alive-broker",
    },
  ]

  // Generate all services
  for (const svc of services) {
    const content = generateService(svc)
    const path = `${generatedDir}/${svc.name}.service`
    await writeFile(path, content)
    console.log(`${COLORS.green}âœ“${COLORS.reset} ${svc.name}.service`)
  }

  // Generate preview-proxy service (opt-in: only when previewProxy.port is set)
  const previewPort = config.previewProxy?.port
  if (previewPort) {
    const previewBase = config.domains.previewBase
    const frameAncestors = config.domains.frameAncestors ?? []
    const portMapPath = `${generatedDir}/port-map.json`

    const previewProxyCfg: GoServiceConfig = {
      name: "preview-proxy",
      description: "Alive Preview Proxy (Go)",
      workingDir: `${aliveRoot}/apps/preview-proxy`,
      execStart: `${aliveRoot}/apps/preview-proxy/dist/preview-proxy`,
      envFiles: [`${aliveRoot}/.env.local`],
      envVars: {
        PREVIEW_BASE: previewBase,
        LISTEN_ADDR: `:${previewPort}`,
        PORT_MAP_PATH: portMapPath,
        FRAME_ANCESTORS: frameAncestors.join(","),
      },
      memory: { max: "128M", high: "96M" },
      cpu: "50%",
      tasksMax: 128,
      syslogId: "preview-proxy",
    }

    const content = generateGoService(previewProxyCfg)
    const path = `${generatedDir}/${previewProxyCfg.name}.service`
    await writeFile(path, content)
    console.log(`${COLORS.green}âœ“${COLORS.reset} ${previewProxyCfg.name}.service`)
  } else {
    console.log(
      `${COLORS.dim}-${COLORS.reset} preview-proxy.service ${COLORS.dim}(skipped: previewProxy.port not set)${COLORS.reset}`,
    )
  }

  console.log(`
${COLORS.dim}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${COLORS.reset}

Install:  cp ${generatedDir}/*.service /etc/systemd/system/
          systemctl daemon-reload

Start:    systemctl start alive-dev
Enable:   systemctl enable alive-dev

Logs:     journalctl -u alive-dev -f
`)
}

main().catch(e => {
  console.error(`${COLORS.red}Fatal:${COLORS.reset}`, e.message)
  process.exit(1)
})
