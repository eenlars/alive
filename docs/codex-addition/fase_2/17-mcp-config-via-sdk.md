# Fase 2.17 — Passing MCP Server Config to Codex via SDK

## The Key Insight

Codex normally reads MCP server config from `config.toml`:
```toml
[mcp_servers.alive-tools]
command = "/path/to/alive-mcp-tools"
args = ["--workspace", "/srv/workspace/abc"]

[mcp_servers.alive-workspace]
command = "/path/to/alive-mcp-workspace"
args = ["--root", "/srv/workspace/abc"]
```

The SDK's `config` option serializes to `--config` CLI flags, which are TOML overrides.

## Can we pass MCP servers via SDK config option?

```typescript
const codex = new Codex({
  config: {
    mcp_servers: {
      "alive-tools": {
        command: "/path/to/alive-mcp-tools",
        args: ["--workspace", "/srv/workspace/abc"]
      }
    }
  }
});
```

This would serialize to:
```shell
--config mcp_servers.alive-tools.command="/path/to/alive-mcp-tools"
--config mcp_servers.alive-tools.args=["--workspace", "/srv/workspace/abc"]
```

### Problem: TOML array serialization

The SDK's `toTomlValue` handles arrays:
```typescript
if (Array.isArray(value)) {
  const rendered = value.map((item, index) => toTomlValue(item, `${path}[${index}]`));
  return `[${rendered.join(", ")}]`;
}
```

So `args: ["--workspace", "/srv/workspace/abc"]` becomes: `args=["--workspace", "/srv/workspace/abc"]`

This should work with TOML parsing on the Rust side, but the `mcp_servers` config structure needs verification.

### From the Rust config source

`McpServerRequirement` has:
```rust
pub enum McpServerIdentity {
    Command { command: String },
    Url { url: String },
}

pub struct McpServerRequirement {
    pub identity: McpServerIdentity,
}
```

This is the **requirements** layer. The actual runtime MCP config may differ. The requirements only have `command` or `url` identity — no `args` or `env` fields.

**CONCERN**: The requirements config may not support full MCP server specs (args, env). If so, we need an alternative approach.

## Alternative: Write config.toml per session

Instead of passing via SDK config option, write a temporary `config.toml`:

```typescript
async function writeCodexConfig(sessionDir: string, mcpServers: McpServerSpec[]) {
  const configDir = path.join(sessionDir, '.codex');
  await mkdir(configDir, { recursive: true });

  const escapeTOML = (s: string) => s.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
  const toml = mcpServers.map(s => `
[mcp_servers."${escapeTOML(s.name)}"]
command = "${escapeTOML(s.command)}"
args = ${JSON.stringify(s.args || [])}
${s.env ? Object.entries(s.env).map(([k,v]) => `env.${escapeTOML(k)} = "${escapeTOML(v)}"`).join('\n') : ''}
`).join('\n');

  await writeFile(path.join(configDir, 'config.toml'), toml);
}
```

Then set `workingDirectory` to that session dir so Codex picks up the project-level config.

## Recommended Approach

**Use project-level config.toml** (not SDK config option):
1. Create `.codex/config.toml` in workspace directory before spawning Codex
2. Include full MCP server specs with command, args, and env
3. Codex reads this automatically when `workingDirectory` points to the workspace
4. Clean up on session end

This is more reliable than trying to serialize complex nested TOML via CLI flags.

### Implementation

```typescript
class CodexProvider {
  async createSession(config: ProviderConfig): Promise<AgentSession> {
    // Write .codex/config.toml with MCP servers
    await this.writeProjectConfig(config.workspacePath, config.mcpServers);
    
    // Write CODEX.md with system prompt
    await this.injectSystemPrompt(config.workspacePath, config.systemPrompt);
    
    const codex = new Codex({
      apiKey: process.env.OPENAI_API_KEY,
      env: this.buildEnv(config),
    });
    
    const thread = codex.startThread({
      workingDirectory: config.workspacePath,
      sandboxMode: 'workspace-write',
      approvalPolicy: 'never',
      skipGitRepoCheck: true,
    });
    
    return new CodexSession(thread, config);
  }
  
  private async writeProjectConfig(workspacePath: string, mcpServers: McpServerSpec[]) {
    const configDir = path.join(workspacePath, '.codex');
    await mkdir(configDir, { recursive: true });
    
    let toml = '# Auto-generated by Alive\n\n';
    const escapeTOML = (s: string) => s.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
    for (const server of mcpServers) {
      toml += `[mcp_servers."${escapeTOML(server.name)}"]\n`;
      toml += `command = "${escapeTOML(server.command)}"\n`;
      if (server.args?.length) {
        toml += `args = [${server.args.map(a => `"${a}"`).join(', ')}]\n`;
      }
      if (server.env) {
        for (const [k, v] of Object.entries(server.env)) {
          toml += `env.${escapeTOML(k)} = "${escapeTOML(v)}"\n`;
        }
      }
      toml += '\n';
    }
    
    await writeFile(path.join(configDir, 'config.toml'), toml);
  }
}
```

## Env in MCP servers

From the Codex TOML config, MCP servers can have an `env` table:
```toml
[mcp_servers.my-server]
command = "/path/to/server"
[mcp_servers.my-server.env]
WORKSPACE_ID = "abc123"
USER_ID = "user456"
```

**OPEN QUESTION from README**: Is this `env` additive (merged with process env) or replacing?
Based on typical MCP server implementations and the fact that the Rust code manages child process spawning, it's likely **additive** — these env vars are added on top of the inherited environment. This makes sense because MCP servers need PATH, HOME, etc.
