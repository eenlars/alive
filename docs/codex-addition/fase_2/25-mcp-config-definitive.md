# MCP Server Configuration — Definitive Approach

## Strategy: Project-Level config.toml + SDK config option

Based on the verified Rust config schema (fase_1/13), Alive should configure Codex MCP servers using **project-level `.codex/config.toml`** written to each workspace before session start.

## Why config.toml Over SDK config Option

The SDK `config` option flattens to `--config key=value` which works for scalar values but MCP server config is deeply nested TOML (command, args, env, timeouts). The config flattening in `exec.ts` does handle nested objects, but a file is:
- More readable for debugging
- Supports full TOML syntax including arrays-of-tables
- Can be inspected by the user
- Won't hit CLI argument length limits

## Template for Alive Workspace

```toml
# .codex/config.toml — auto-generated by Alive

[mcp_servers.alive-tools]
command = "node"
args = ["/opt/alive/packages/mcp-servers/alive-tools.mjs"]
env = { WORKSPACE_ID = "{{workspaceId}}", USER_ID = "{{userId}}" }
env_vars = ["NODE_ENV", "DATABASE_URL"]
cwd = "{{workspaceRoot}}"
required = true
startup_timeout_sec = 10.0
tool_timeout_sec = 30.0

[mcp_servers.alive-workspace]
command = "node"
args = ["/opt/alive/packages/mcp-servers/alive-workspace.mjs"]
env = { WORKSPACE_ID = "{{workspaceId}}" }
required = true
startup_timeout_sec = 10.0

[mcp_servers.alive-email]
command = "node"
args = ["/opt/alive/packages/mcp-servers/alive-email.mjs"]
env = { WORKSPACE_ID = "{{workspaceId}}", USER_ID = "{{userId}}" }
required = false
startup_timeout_sec = 15.0
```

## env vs env_vars

- `env`: explicit key=value pairs passed to the MCP server process. SDK's `env` option REPLACES process.env.
- `env_vars`: list of env var NAMES to passthrough from the parent process. This is additive.

For Alive: use `env` for workspace-specific context, `env_vars` for shared infra vars (`NODE_ENV`, `DATABASE_URL`).

## Tool Filtering

Can use `enabled_tools` / `disabled_tools` per MCP server to restrict what tools are available per workspace tier:

```toml
[mcp_servers.alive-tools]
command = "node"
args = ["/opt/alive/packages/mcp-servers/alive-tools.mjs"]
enabled_tools = ["read_file", "write_file", "search_files"]  # free tier
```

This is a product feature opportunity — different workspace plans get different tool access.

## CodexProvider Implementation

```typescript
async function writeCodexConfig(workspaceDir: string, opts: {
  workspaceId: string;
  userId: string;
  mcpServers: McpServerSpec[];
  developerInstructions?: string;
}): Promise<void> {
  const codexDir = path.join(workspaceDir, '.codex');
  await mkdir(codexDir, { recursive: true });
  
  const config: Record<string, unknown> = {
    mcp_servers: Object.fromEntries(
      opts.mcpServers.map(s => [s.name, {
        command: s.command,
        args: s.args,
        env: s.env,
        required: s.required ?? true,
        startup_timeout_sec: s.startupTimeoutSec ?? 10,
        tool_timeout_sec: s.toolTimeoutSec ?? 30,
      }])
    ),
  };
  
  // Note: developer_instructions goes via SDK config option, not file
  await writeFile(
    path.join(codexDir, 'config.toml'),
    toml.stringify(config)
  );
}
```

## Cleanup

The `.codex/config.toml` file should be:
- Written BEFORE starting Codex thread
- Left in place during session (Codex may re-read on thread resume)
- Cleaned up when workspace is deactivated or destroyed

## Session Directory Isolation

Codex stores sessions in `~/.codex/sessions/`. To isolate per-workspace:
```typescript
const codex = new Codex({
  env: {
    ...processEnv,
    CODEX_HOME: path.join(workspaceDir, '.codex'),
  }
});
```

This makes `config.toml` lookup also use the workspace-local `.codex/` dir. Perfect alignment.

## Supersedes
- fase_2/17 (MCP config via SDK) — refined with full Rust schema knowledge
